package db

import (
	"context"
	"fmt"

	"github.com/rs/zerolog/log"
	"github.com/scalarorg/data-models/chains"
	"github.com/scalarorg/data-models/scalarnet"
	"gorm.io/gorm"
)

// find relay datas by token sent attributes
func (db *DatabaseAdapter) FindPendingBtcTokenSent(sourceChain string, height int) ([]*chains.TokenSent, error) {
	var tokenSents []*chains.TokenSent
	result := db.PostgresClient.
		Where("source_chain = ? AND block_number <= ?",
			sourceChain,
			height).
		Where("status = ?", string(chains.TokenSentStatusPending)).
		Find(&tokenSents)

	if result.Error != nil {
		return tokenSents, fmt.Errorf("FindPendingBtcTokenSent with error: %w", result.Error)
	}
	if len(tokenSents) == 0 {
		log.Warn().
			Str("sourceChain", sourceChain).
			Msgf("[DatabaseAdapter] [FindPendingBtcTokenSent] no token sent with block height before %d found", height)
	}
	return tokenSents, nil
}

/*
Remove token sents with same tx_hash due to reorg of the bitcoin
delete the token sents with the same tx_hash and block_number < the new token sent
For high performance, we insert token to a temporary table, then update of crete by join 2 tables
*/
func (db *DatabaseAdapter) SaveTokenSentsAndRemoveDuplicates(tokenSents []*chains.TokenSent) error {
	log.Debug().Msgf("[DatabaseAdapter] [SaveTokenSentsAndRemoveDuplicates] save token sents and remove duplicates")
	txHashes := make([]string, 0)
	for _, tokenSent := range tokenSents {
		txHashes = append(txHashes, tokenSent.TxHash)
	}
	var existingTokenSents []chains.TokenSent
	db.PostgresClient.Model(&chains.TokenSent{}).Where("tx_hash IN ?", txHashes).Find(&existingTokenSents)
	mapTokens := make(map[string]*chains.TokenSent)
	for _, tokenSent := range existingTokenSents {
		mapTokens[tokenSent.TxHash] = &tokenSent
	}
	removeHashes := make([]string, 0)
	newTokenSents := make([]*chains.TokenSent, 0)
	for _, tokenSent := range tokenSents {
		existingItem, ok := mapTokens[tokenSent.TxHash]
		if !ok {
			//TokenSent is not exist, create new one
			newTokenSents = append(newTokenSents, tokenSent)
		} else if existingItem.BlockNumber <= tokenSent.BlockNumber {
			//TokenSent is exist, and block number is less than the new one, so it is a reorged token sent
			removeHashes = append(removeHashes, tokenSent.TxHash)
			newTokenSents = append(newTokenSents, tokenSent)
		} else {
			//TokenSent is exist, and block number is greater than the new one, so it is a new token sent
			//We ignore new coming token sent
		}
	}
	tx := db.PostgresClient.Begin()
	if tx == nil {
		return fmt.Errorf("failed to begin transaction")
	}
	defer tx.Rollback() // Will be ignored if transaction is committed

	// Delete existing verifying entries with matching tx_hashes
	err := tx.Where("tx_hash IN ?", removeHashes).Delete(&chains.TokenSent{}).Error
	if err != nil {
		log.Warn().Err(err).Msgf("[DatabaseAdapter] failed to remove reorged token sents")
		return err
	} else {
		log.Debug().
			Strs("Removed hash", removeHashes).Msgf("[DatabaseAdapter] [SaveTokenSentsAndRemoveDuplicates] removed %d reorged token sents", len(removeHashes))
	}

	// Save new token sents
	err = tx.Save(newTokenSents).Error
	if err != nil {
		return fmt.Errorf("[DatabaseAdapter] failed to save new token sents: %w", err)
	} else {
		log.Debug().Msgf("[DatabaseAdapter] [SaveTokenSentsAndRemoveDuplicates] saved %d new token sents", len(tokenSents))
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		return fmt.Errorf("[DatabaseAdapter] failed to commit transaction: %w", err)
	}

	return nil
}

func (db *DatabaseAdapter) SaveTokenSents(tokenSents []*chains.TokenSent) error {
	result := db.PostgresClient.Save(tokenSents)
	if result.Error != nil {
		return result.Error
	}
	return nil
}

// Save token sent generated by evm
func (db *DatabaseAdapter) SaveTokenSent(tokenSent chains.TokenSent, lastCheckpoint *scalarnet.EventCheckPoint) error {
	err := db.PostgresClient.Transaction(func(tx *gorm.DB) error {
		result := tx.Save(&tokenSent)
		if result.Error != nil {
			return result.Error
		}
		if lastCheckpoint != nil {
			UpdateLastEventCheckPoint(tx, lastCheckpoint)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to create evm token send: %w", err)
	}
	return nil
}

func (db *DatabaseAdapter) UpdateTokenSentsStatus(ctx context.Context, cmdIds []string, status chains.TokenSentStatus) error {
	log.Debug().Any("cmdIds", cmdIds).Msg("[DatabaseAdapter] UpdateTokenSentsStatus")
	err := db.PostgresClient.Transaction(func(tx *gorm.DB) error {
		eventIds := tx.Model(&scalarnet.TokenSentApproved{}).Select("event_id").Where("command_id IN (?)", cmdIds)
		tokenSents := []*chains.TokenSent{}
		//only update the token sent that is not success
		result := tx.Model(&chains.TokenSent{}).Where("event_id IN (?) and status != ?", eventIds, chains.TokenSentStatusSuccess).Find(&tokenSents)
		if result.Error == nil {
			ids := []string{}
			for _, tokenSent := range tokenSents {
				ids = append(ids, tokenSent.EventID)
			}
			result = tx.Model(&chains.TokenSent{}).Where("event_id IN (?)", ids).Update("status", status)
		}
		return result.Error
	})
	return err
}

func (db *DatabaseAdapter) SaveTokenDeployed(tokenDeployed *chains.TokenDeployed) error {
	result := db.PostgresClient.Save(tokenDeployed)
	if result.Error != nil {
		return result.Error
	}
	return nil
}
